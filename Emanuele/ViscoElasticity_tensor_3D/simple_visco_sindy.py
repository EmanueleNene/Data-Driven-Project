import numpy as np
import matplotlib.pyplot as plt
import pysindy as ps
from scipy.integrate import odeint

# ==========================================
# 1. SYNTHETIC DATA GENERATION (Maxwell Model)
#    Equation: d(sig)/dt = E * d(eps)/dt - (E/eta) * sig
# ==========================================

# Parameters
E_true = 2000.0      # Elastic modulus
eta_true = 500.0     # Viscosity
dt = 0.001           # Time step
t = np.arange(0, 10, dt)

def maxwell_ode(sig, t, eps_dot_interp, t_interp):
    # Interpolate eps_dot at time t
    ed = np.interp(t, t_interp, eps_dot_interp)
    # ODE: sig_dot = E * eps_dot - (E/eta) * sig
    dsig_dt = E_true * ed - (E_true / eta_true) * sig
    return dsig_dt

def generate_data(eps_func, t):
    eps = eps_func(t)
    eps_dot = np.gradient(eps, dt)
    sig0 = 0.0
    sig = odeint(maxwell_ode, sig0, t, args=(eps_dot, t)).flatten()
    return eps, eps_dot, sig

# --- Training Data (Rich signal) ---
# Sum of sines to excite multiple frequencies
def train_strain(t):
    return 0.01 * np.sin(2 * np.pi * 0.5 * t) + 0.005 * np.sin(2 * np.pi * 1.5 * t)

eps_train, eps_dot_train, sig_train = generate_data(train_strain, t)

# Add noise to training data
np.random.seed(42)
sig_train_noisy = sig_train + np.random.normal(0, 0.1, size=len(sig_train))

# --- Validation Data (Simple signal, unseen) ---
# Different frequency and amplitude
def val_strain(t):
    return 0.015 * np.sin(2 * np.pi * 0.2 * t)

eps_val, eps_dot_val, sig_val = generate_data(val_strain, t)


# ==========================================
# 2. SINDy TRAINING (On Training Data ONLY)
# ==========================================

# Prepare Training Data
# SINDy requires data in (n_samples, n_features) format.
# We reshape our 1D arrays to 2D arrays with 1 column.
X_train = sig_train_noisy.reshape(-1, 1)
U_train = eps_dot_train.reshape(-1, 1)

# Define Library & Model
# PolynomialLibrary: Creates candidate functions (features) for the regression.
# degree=3 means we include terms like 1, x, u, x^2, xu, u^2, x^3...
# include_bias=True adds the constant term '1' to the library.
poly_lib = ps.PolynomialLibrary(degree=3, include_bias=True)

# Optimizer: STLSQ (Sequential Thresholded Least Squares)
# This algorithm iteratively finds the sparse solution.
# threshold=0.1: Coefficients smaller than 0.1 are zeroed out (pruned).
#   - Increase threshold to force a sparser model (fewer terms).
#   - Decrease threshold if you suspect small but real terms are being ignored.
opt = ps.STLSQ(threshold=1)

# Initialize SINDy model with our library and optimizer
model = ps.SINDy(feature_library=poly_lib, optimizer=opt)

# Fit Model
print("\n=== Training SINDy Model ===")
# model.fit():
#   x: The state variable(s) we want to model (sig).
#   u: The control input(s) driving the system (eps_dot).
#   t: The time step (dt). SINDy uses this to numerically compute d(sig)/dt from X_train.
#   feature_names: Labels for printing the discovered equation.
model.fit(X_train, u=U_train, t=dt, feature_names=["sig", "eps_dot"])
model.print()

# Check Coefficients
# model.coefficients() returns an array of shape (n_states, n_features).
# Since we have only 1 state variable (sig), we take the first row [0].
# These coefficients correspond to the terms in the library (1, sig, eps_dot, sig^2, ...).
coeffs = model.coefficients()[0]
print(f"Coefficients: {coeffs}")


# ==========================================
# 3. VALIDATION (On Unseen Data)
# ==========================================

# Manual integration using discovered coefficients
# This function defines the ODE using the coefficients found by SINDy.
# We use this to simulate the learned model on new data.
def discovered_ode(sig, t, eps_dot_interp, t_interp, coeffs):
    # Interpolate the input (strain rate) at the current solver time t
    ed = np.interp(t, t_interp, eps_dot_interp)
    
    # Reconstruct derivative: dsig/dt = c0 + c1*sig + c2*eps_dot + ...
    # The 'coeffs' array matches the order of features generated by PolynomialLibrary.
    #
    # IMPORTANT: The order depends on the library settings!
    # For degree=3, include_bias=True, and variables [sig, eps_dot], the standard order is usually:
    # Index 0: 1 (Bias)
    # Index 1: sig
    # Index 2: eps_dot
    # Index 3: sig^2
    # Index 4: sig * eps_dot
    # ... and so on.
    #
    # Here, we explicitly use the first 3 terms because we expect a linear Maxwell model.
    # If SINDy found higher-order terms (non-zero coeffs at indices > 2), 
    # you would need to add them here (e.g., + coeffs[3] * sig**2).
    
    dsig_dt = coeffs[0] + coeffs[1] * sig + coeffs[2] * ed
    return dsig_dt

# Simulate on Validation Input
# We use odeint to solve the 'discovered_ode' using the VALIDATION input (eps_dot_val).
# This tests if the model generalizes to unseen data.
sig_val_pred = odeint(discovered_ode, 0.0, t, args=(eps_dot_val, t, coeffs)).flatten()


# ==========================================
# 4. VISUALIZATION
# ==========================================

width = 9.5;

plt.rcParams.update({
    'font.size': 12,           # Base font size
    'axes.labelsize': 14,      # X and Y axis labels
    'axes.titlesize': 16,      # Subplot titles
    'xtick.labelsize': 11,     # X-axis tick labels
    'ytick.labelsize': 11,     # Y-axis tick labels
    'legend.fontsize': 11,     # Legend text
})



plt.figure(figsize=(width,6))

# --- Row 1: Training Data ---

# 1. Training Inputs
plt.subplot(1, 2, 1)
plt.plot(t, eps_train, 'b-', label=r'$\epsilon$ (Strain)')
plt.plot(t, eps_dot_train, 'g-', alpha=0.7, label=r'$\dot{\epsilon}$ (Strain Rate)')
plt.title("Training Inputs (Rich Signal)")
plt.xlabel("Time")
plt.ylabel("Magnitude")
plt.legend()
plt.grid(True, alpha=0.3)

# 2. Training Outputs (Fit)
# Reconstruct on training data to show fit quality
sig_train_pred = odeint(discovered_ode, 0.0, t, args=(eps_dot_train, t, coeffs)).flatten()

plt.subplot(1, 2, 2)
plt.plot(t, sig_train_noisy, 'k.', alpha=0.1, label="Noisy Data (Input to SINDy)")
plt.plot(t, sig_train, 'k-', alpha=0.3, label="True Signal")
plt.plot(t, sig_train_pred, 'r--', lw=2, label="SINDy Fit")
plt.title("Training Outputs (Reconstruction)")
plt.xlabel("Time")
plt.ylabel("Stress")
plt.legend()
plt.grid(True, alpha=0.3)




# --- Row 2: Validation Data ---
plt.figure(figsize=(width,6))
#  Validation Inputs
plt.subplot(1, 2, 1)
plt.plot(t, eps_val, 'b-', label=r'$\epsilon$ (Strain)')
plt.plot(t, eps_dot_val, 'g-', alpha=0.7, label=r'$\dot{\epsilon}$ (Strain Rate)')
plt.title("Validation Inputs (Unseen Signal)")
plt.xlabel("Time")
plt.ylabel("Magnitude")
plt.legend()
plt.grid(True, alpha=0.3)

#  Validation Outputs (Prediction)
plt.subplot(1, 2, 2)
plt.plot(t, sig_val, 'k-', lw=1, label="True Signal")
plt.plot(t, sig_val_pred, 'r--', lw=2, label="SINDy Prediction")
plt.title("Validation Outputs (Generalization)")
plt.xlabel("Time")
plt.ylabel("Stress")
plt.legend()
plt.grid(True, alpha=0.3)


#################################################################

plt.figure(figsize=(width,6))

#  Training Stress-Strain Plot
plt.subplot(1, 2, 1)
plt.plot(eps_train, sig_train, 'k-', alpha=0.3, label="True")
plt.plot(eps_train, sig_train_pred, 'r--', lw=2, label="SINDy Fit")
plt.title("Training Stress-Strain")
plt.xlabel(r"Strain $\epsilon$")
plt.ylabel(r"Stress $\sigma$")
plt.legend()
plt.grid(True, alpha=0.3)

#  Validation Stress-Strain Plot
plt.subplot(1,2,2)
plt.plot(eps_val, sig_val, 'k-', lw=1, label="True")
plt.plot(eps_val, sig_val_pred, 'r--', lw=2, label="SINDy Prediction")
plt.title("Validation Stress-Strain")
plt.xlabel(r"Strain $\epsilon$")
plt.ylabel(r"Stress $\sigma$")
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()


"""plt.tight_layout()
plt.show()
#plt.tight_layout()
plt.savefig('maxwell_sindy_comprehensive.png')
print("\nPlot saved to maxwell_sindy_comprehensive.png")"""
